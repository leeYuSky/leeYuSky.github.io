<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.5.2">Jekyll</generator><link href="http://localhost:4000/atom.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2018-06-28T21:20:35+08:00</updated><id>http://localhost:4000/</id><title type="html">强迫自己写点什么之博客</title><subtitle>It's NULL.</subtitle><author><name>leeYu</name></author><entry><title type="html">设计模式-代理模式</title><link href="http://localhost:4000/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2016/05/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/" rel="alternate" type="text/html" title="设计模式-代理模式" /><published>2016-05-05T00:00:00+08:00</published><updated>2016-05-05T00:00:00+08:00</updated><id>http://localhost:4000/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2016/05/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F</id><content type="html" xml:base="http://localhost:4000/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/2016/05/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/">&lt;h2 id=&quot;代理模式&quot;&gt;代理模式&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;代理(Proxy)是一种设计模式,提供了对目标对象另外的访问方式；即通过代理对象访问目标对象。这样做的好处是:可以在目标对象实现的基础上,增强额外的功能操作,即扩展目标对象的功能。
这里使用到编程中的一个思想：不要随意去修改别人已经写好的代码或者方法,如果需改修改,可以通过代理的方式来扩展该方法。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//移动接口
public interface Moveable {

	public void move();

}
//汽车实现类
public class Car implements Moveable{
	@Override
	public void move() {	
		System.out.println(&quot;汽车行驶中&quot;);	
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;静态代理&quot;&gt;静态代理&lt;/h3&gt;
&lt;h4 id=&quot;继承方式&quot;&gt;继承方式&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class Car2 extends Car{
	@Override
	public void move() {	
		System.out.println(&quot;日志开始&quot;);
		System.out.println(&quot;汽车行驶中&quot;);	
		System.out.println(&quot;日志结束&quot;);
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我们可以看到，如果我们想增加别的功能，需要在新声明Car3,Car4等等.比如time功能，time和log的前后顺序不同也影响我们对类的构造。&lt;/p&gt;
&lt;h4 id=&quot;聚合方式&quot;&gt;聚合方式&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class CarTimeProxy implements Moveable {

	public CarTimeProxy(Moveable m) {
		super();
		this.m = m;
	}

	private Moveable m;

	@Override
	public void move() {
		long starttime = System.currentTimeMillis();
		System.out.println(&quot;汽车开始行驶....&quot;);
		m.move();
		long endtime = System.currentTimeMillis();
		System.out.println(&quot;汽车结束行驶....  行驶时间为:&quot; 
			+ (endtime - starttime) + &quot;毫秒!&quot;);
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我们可以看到，我们调用此次代理只需要:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Car car = new Car();
Moveable m = new CarTimeProxy(car);
m.move();
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;假如我们还需要一个日志代理类&lt;code class=&quot;highlighter-rouge&quot;&gt;CarLogProxy()&lt;/code&gt;,只需要:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Car car = new Car();
Moveable m1 = new CarTimeProxy(car);
Moveable m2 = new CarLogProxy(m1);
m2.move(); 可以有效减少类的数量。
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;结论&lt;/strong&gt;:聚合比继承更适合代理模式&lt;/p&gt;

&lt;h3 id=&quot;动态代理&quot;&gt;动态代理&lt;/h3&gt;

&lt;h4 id=&quot;jdk动态代理&quot;&gt;JDK动态代理&lt;/h4&gt;
&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;只能代理实现了接口的类&lt;/li&gt;
    &lt;li&gt;没有实现接口的类不能使用JDK动态代理&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Proxy;

public class proxyOfJDK {

	public static void main(String[] main){
		Car car = new Car();
		InvocationHandler h = new TimeHandler(car);
		Class cls  = car.getClass();
	
		Moveable m ＝(Moveable)Proxy.newProxyInstance(cls.getClassLoader(), 
								cls.getInterfaces(), h);
		m.move();
	}

}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;需要实现InvocationHandler接口：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;

public class TimeHandler implements InvocationHandler {
	//目标对象
	private Object target;
	
	public TimeHandler(Object target) {
		super();
		this.target = target;
	}
	
	/**
	 * proxy 代理对象
	 * method 实现方法
	 * args 方法参数
	 */
	@Override
	public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
		// TODO Auto-generated method stub
		
		System.out.println(&quot;汽车开始行驶...\t\n&quot;);
		//Class clazz = proxy.getClass();
		//System.out.println(clazz.getName());
		//Method[] m = clazz.getDeclaredMethods();
		//for (Method method2 : m) {
		//	System.out.println(method2.getName());
		//}
		
		method.invoke(target);
		System.out.println(&quot;汽车结束行驶...&quot;);
		
		return null;
	}

}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;生成的代理对象的class为&lt;code class=&quot;highlighter-rouge&quot;&gt;com.sun.proxy.$Proxy0&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;2016-6-27回顾心得：&lt;strong&gt;此模式如果接口默认继承Object，那么toString()等函数也被加上了代理。即通过method.invoke(target);方法，那么所有的method都将添加代理。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;cjlib动态代理&quot;&gt;CJLIB动态代理&lt;/h4&gt;
&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;针对类来实现动态代理的&lt;/li&gt;
    &lt;li&gt;对指定目标类产生一个子类，通过方法拦截技术拦截所有父类的方法调用
火车类：&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class Train {
	
	public void move(){
		System.out.println(&quot;火车行驶中&quot;);
	}

}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;需要实现MethodInterceptor接口&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import java.lang.reflect.Method;

import net.sf.cglib.proxy.Enhancer;
import net.sf.cglib.proxy.MethodInterceptor;
import net.sf.cglib.proxy.MethodProxy;

public class proxyOfCJLIB implements MethodInterceptor {

	private Enhancer enhancer = new Enhancer();
	
	public Object getProxy(Class clazz){
		//设置创建子类的类
		enhancer.setSuperclass(clazz);
		enhancer.setCallback(this);
		
		return enhancer.create();
	}
	
	/**
	 * 拦截所有目标类的调用
	 * obj 目标类的实例
	 * m 目标方法的反射对象
	 * args 方法的参数
	 * proxy 代理类的实例
	 */
	@Override
	public Object intercept(Object object, Method m, Object[] arg2, 
			MethodProxy proxy) throws Throwable {
		System.out.println(&quot;日志开始&quot;);
		//代理类调用父类的方法
		proxy.invokeSuper(object, arg2);
		
		System.out.println(&quot;日志结束&quot;);
		// TODO Auto-generated method stub
		return null;
	}

}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;测试：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class Client {
	
	public static void main(String[] args){
		proxyOfCJLIB proxy = new proxyOfCJLIB();
		Train t = (Train) proxy.getProxy(Train.class);
		t.move();
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;动态代理实现思路&quot;&gt;动态代理实现思路&lt;/h3&gt;
&lt;blockquote&gt;

  &lt;p&gt;实现功能：通过Proxy的newProxyInstance返回代理对象&lt;/p&gt;

  &lt;ol&gt;
    &lt;li&gt;声明一段源码（动态代理产生）&lt;/li&gt;
    &lt;li&gt;编译源码（JDK Compiler API）,产生新的类（代理类）&lt;/li&gt;
    &lt;li&gt;讲这个类load到内存当中，产生一个新的对象（代理对象）&lt;/li&gt;
    &lt;li&gt;return 代理对象&lt;/li&gt;
  &lt;/ol&gt;

  &lt;p&gt;Proxy类&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package cn.tju.scs.proxy;

import java.io.File;
import java.lang.reflect.Constructor;
import java.lang.reflect.Method;

import javax.tools.JavaCompiler;
import javax.tools.JavaCompiler.CompilationTask;
import javax.tools.StandardJavaFileManager;
import javax.tools.ToolProvider;

import org.apache.commons.io.FileUtils;

import cn.tju.scs.Car;

public class Proxy {

	public static Object newProxyInstance(Class infce,InvocationHandler h) throws Exception{
		
		String rt = &quot;\t\n&quot;;
		String methodStr =&quot;&quot;;
		for (Method m : infce.getMethods()) {
			methodStr += &quot;	@Override&quot; + rt + 
			&quot;	public void &quot;+m.getName()+&quot;() {&quot; + rt + 
			&quot;   try{&quot; + rt + 
			&quot;	Method md = &quot; + infce.getName() + &quot;.class.getMethod(\&quot;&quot;+m.getName()+&quot;\&quot;);&quot; + rt + 
			&quot;   h.invoke(this,md);&quot;+ rt + 
			&quot;   }catch(Exception e){ e.printStackTrace();}&quot; + rt + 
			&quot;	}&quot;;
		}
		String str = 
		&quot;package cn.tju.scs.proxy;&quot; + rt + 
		&quot;import java.lang.reflect.Method;&quot;+ rt + 
		&quot;import cn.tju.scs.proxy.InvocationHandler;&quot; + rt + 
		&quot;public class $Proxy0 implements &quot;+ infce.getName()+&quot;{&quot; + rt + 
		&quot;	public $Proxy0(InvocationHandler h) {&quot; + rt + 
		&quot;		super();&quot; + rt + 
		&quot;		this.h = h;&quot; + rt + 
		&quot;	}&quot; + rt + 

		&quot;   private InvocationHandler h;&quot; + rt + 
		
		
		methodStr + rt + 
		&quot;}&quot;;
		
		String filename = System.getProperty(&quot;user.dir&quot;)+&quot;/bin/cn/tju/scs/proxy/$Proxy0.java&quot;;

		File file = new File(filename);
		FileUtils.writeStringToFile(file, str);
		
		//编译
		//拿到编译器
		JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
		//第一个参数：监听器
		//文件管理者
		StandardJavaFileManager fileMgr = 
				compiler.getStandardFileManager(null, null, null);
		//获取文件
		Iterable units = fileMgr.getJavaFileObjects(filename);
		//编译任务
		CompilationTask t = compiler.getTask(null, fileMgr, null, null, null, units);
		//进行编译
		t.call();
		fileMgr.close();
		
		//load到内存
		ClassLoader cl = ClassLoader.getSystemClassLoader();
		Class c = cl.loadClass(&quot;cn.tju.scs.proxy.$Proxy0&quot;); 
		
		Constructor ctr = c.getConstructor(InvocationHandler.class);
		
		return ctr.newInstance(h);
	}

} &amp;gt;TimeHandler

package cn.tju.scs.proxy;

import java.lang.reflect.Method;

public class TimeHandler implements InvocationHandler {

	private Object target;
	
	
	
	public TimeHandler(Object target) {
		super();
		this.target = target;
	}



	@Override
	public void invoke(Object obj, Method m) {
		// TODO Auto-generated method stub
		try {
			long starttime = System.currentTimeMillis();
			System.out.println(&quot;汽车开始行驶....&quot;);
			m.invoke(target);
			long endtime = System.currentTimeMillis();
			System.out.println(&quot;汽车结束行驶....  行驶时间为:&quot;+ 
			+ (endtime - starttime) + &quot;毫米!&quot;);

		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;生成的代理类$Proxy0:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package cn.tju.scs.proxy;	
import java.lang.reflect.Method;	
import cn.tju.scs.proxy.InvocationHandler;	
public class $Proxy0 implements cn.tju.scs.Moveable{	
	public $Proxy0(InvocationHandler h) {	
		super();	
		this.h = h;	
	}	
	private InvocationHandler h;	
	@Override	
	public void move() {	
	try{	
	Method md = cn.tju.scs.Moveable.class.getMethod(&quot;move&quot;);	
	h.invoke(this,md);	
	}catch(Exception e){ e.printStackTrace();}	
	}	
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;测试类：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package cn.tju.scs.proxy;

import cn.tju.scs.Car;
import cn.tju.scs.Moveable;

public class Client {

	public static void main(String[] args) throws Exception {
		// TODO Auto-generated method stub
		Car car = new Car();
		InvocationHandler h = new TimeHandler(car);
		Moveable m = (Moveable) Proxy.newProxyInstance(Moveable.class,h);
		m.move();

		

	}

}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;通过源代码可以看出来，动态代理&lt;/p&gt;</content><author><name>leeYu</name></author><category term="设计模式" /><category term="代理" /><summary type="html">代理模式</summary></entry></feed>